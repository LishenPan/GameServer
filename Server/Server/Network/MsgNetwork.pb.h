// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgNetwork.proto

#ifndef PROTOBUF_MsgNetwork_2eproto__INCLUDED
#define PROTOBUF_MsgNetwork_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "MsgMove.pb.h"
#include "MsgConnect.pb.h"
#include "MsgRoleSelect.pb.h"
#include "MsgInproc.pb.h"
#include "MsgError.pb.h"
#include "MsgRoleInfo.pb.h"
#include "MsgLoginStep.pb.h"
#include "MsgCommon.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_MsgNetwork_2eproto();
void protobuf_AssignDesc_MsgNetwork_2eproto();
void protobuf_ShutdownFile_MsgNetwork_2eproto();

class CMsgNetwork;

enum MESSAGE_TYPE {
  MESSAGE_TYPE_NONE = 0,
  MESSAGE_TYPE_IPC_BEGIN = 1,
  MESSAGE_TYPE_IPC_END = 10000,
  MESSAGE_TYPE_AS_BEGIN = 10001,
  MESSAGE_TYPE_AS_END = 20000,
  MESSAGE_TYPE_WS_BEGIN = 20001,
  MESSAGE_TYPE_WS_END = 30000,
  MESSAGE_TYPE_GS_BEIGN = 30001,
  MESSAGE_TYPE_GS_END = 40000
};
bool MESSAGE_TYPE_IsValid(int value);
const MESSAGE_TYPE MESSAGE_TYPE_MIN = MESSAGE_TYPE_NONE;
const MESSAGE_TYPE MESSAGE_TYPE_MAX = MESSAGE_TYPE_GS_END;
const int MESSAGE_TYPE_ARRAYSIZE = MESSAGE_TYPE_MAX + 1;

// ===================================================================

class CMsgNetwork : public ::google::protobuf::MessageLite {
 public:
  CMsgNetwork();
  virtual ~CMsgNetwork();

  CMsgNetwork(const CMsgNetwork& from);

  inline CMsgNetwork& operator=(const CMsgNetwork& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CMsgNetwork& default_instance();

  enum RealMessageCase {
    kMsgInproc = 2,
    kMsgMove = 30002,
    kMsgConnect = 30003,
    kMsgRoleSelect = 30004,
    kMsgError = 30005,
    kMsgRoleInfo = 30006,
    kMsgLoginStep = 30007,
    kMsgCommon = 30008,
    REALMESSAGE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CMsgNetwork* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CMsgNetwork* other);

  // implements Message ----------------------------------------------

  inline CMsgNetwork* New() const { return New(NULL); }

  CMsgNetwork* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CMsgNetwork& from);
  void MergeFrom(const CMsgNetwork& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CMsgNetwork* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CMsgInproc msgInproc = 2;
  bool has_msginproc() const;
  void clear_msginproc();
  static const int kMsgInprocFieldNumber = 2;
  const ::CMsgInproc& msginproc() const;
  ::CMsgInproc* mutable_msginproc();
  ::CMsgInproc* release_msginproc();
  void set_allocated_msginproc(::CMsgInproc* msginproc);

  // optional .CMsgMove msgMove = 30002;
  bool has_msgmove() const;
  void clear_msgmove();
  static const int kMsgMoveFieldNumber = 30002;
  const ::CMsgMove& msgmove() const;
  ::CMsgMove* mutable_msgmove();
  ::CMsgMove* release_msgmove();
  void set_allocated_msgmove(::CMsgMove* msgmove);

  // optional .CMsgConnect msgConnect = 30003;
  bool has_msgconnect() const;
  void clear_msgconnect();
  static const int kMsgConnectFieldNumber = 30003;
  const ::CMsgConnect& msgconnect() const;
  ::CMsgConnect* mutable_msgconnect();
  ::CMsgConnect* release_msgconnect();
  void set_allocated_msgconnect(::CMsgConnect* msgconnect);

  // optional .CMsgRoleSelect msgRoleSelect = 30004;
  bool has_msgroleselect() const;
  void clear_msgroleselect();
  static const int kMsgRoleSelectFieldNumber = 30004;
  const ::CMsgRoleSelect& msgroleselect() const;
  ::CMsgRoleSelect* mutable_msgroleselect();
  ::CMsgRoleSelect* release_msgroleselect();
  void set_allocated_msgroleselect(::CMsgRoleSelect* msgroleselect);

  // optional .CMsgError msgError = 30005;
  bool has_msgerror() const;
  void clear_msgerror();
  static const int kMsgErrorFieldNumber = 30005;
  const ::CMsgError& msgerror() const;
  ::CMsgError* mutable_msgerror();
  ::CMsgError* release_msgerror();
  void set_allocated_msgerror(::CMsgError* msgerror);

  // optional .CMsgRoleInfo msgRoleInfo = 30006;
  bool has_msgroleinfo() const;
  void clear_msgroleinfo();
  static const int kMsgRoleInfoFieldNumber = 30006;
  const ::CMsgRoleInfo& msgroleinfo() const;
  ::CMsgRoleInfo* mutable_msgroleinfo();
  ::CMsgRoleInfo* release_msgroleinfo();
  void set_allocated_msgroleinfo(::CMsgRoleInfo* msgroleinfo);

  // optional .CMsgLoginStep msgLoginStep = 30007;
  bool has_msgloginstep() const;
  void clear_msgloginstep();
  static const int kMsgLoginStepFieldNumber = 30007;
  const ::CMsgLoginStep& msgloginstep() const;
  ::CMsgLoginStep* mutable_msgloginstep();
  ::CMsgLoginStep* release_msgloginstep();
  void set_allocated_msgloginstep(::CMsgLoginStep* msgloginstep);

  // optional .CMsgCommon msgCommon = 30008;
  bool has_msgcommon() const;
  void clear_msgcommon();
  static const int kMsgCommonFieldNumber = 30008;
  const ::CMsgCommon& msgcommon() const;
  ::CMsgCommon* mutable_msgcommon();
  ::CMsgCommon* release_msgcommon();
  void set_allocated_msgcommon(::CMsgCommon* msgcommon);

  // optional uint64 idSocket = 100000;
  bool has_idsocket() const;
  void clear_idsocket();
  static const int kIdSocketFieldNumber = 100000;
  ::google::protobuf::uint64 idsocket() const;
  void set_idsocket(::google::protobuf::uint64 value);

  // optional bool bBroadcast = 100001;
  bool has_bbroadcast() const;
  void clear_bbroadcast();
  static const int kBBroadcastFieldNumber = 100001;
  bool bbroadcast() const;
  void set_bbroadcast(bool value);

  // repeated uint64 idPeer = 100002;
  int idpeer_size() const;
  void clear_idpeer();
  static const int kIdPeerFieldNumber = 100002;
  ::google::protobuf::uint64 idpeer(int index) const;
  void set_idpeer(int index, ::google::protobuf::uint64 value);
  void add_idpeer(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      idpeer() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_idpeer();

  RealMessageCase RealMessage_case() const;
  // @@protoc_insertion_point(class_scope:CMsgNetwork)
 private:
  inline void set_has_msginproc();
  inline void set_has_msgmove();
  inline void set_has_msgconnect();
  inline void set_has_msgroleselect();
  inline void set_has_msgerror();
  inline void set_has_msgroleinfo();
  inline void set_has_msgloginstep();
  inline void set_has_msgcommon();
  inline void set_has_idsocket();
  inline void clear_has_idsocket();
  inline void set_has_bbroadcast();
  inline void clear_has_bbroadcast();

  inline bool has_RealMessage() const;
  void clear_RealMessage();
  inline void clear_has_RealMessage();

  ::std::string _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 idsocket_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > idpeer_;
  bool bbroadcast_;
  union RealMessageUnion {
    RealMessageUnion() {}
    ::CMsgInproc* msginproc_;
    ::CMsgMove* msgmove_;
    ::CMsgConnect* msgconnect_;
    ::CMsgRoleSelect* msgroleselect_;
    ::CMsgError* msgerror_;
    ::CMsgRoleInfo* msgroleinfo_;
    ::CMsgLoginStep* msgloginstep_;
    ::CMsgCommon* msgcommon_;
  } RealMessage_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgNetwork_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgNetwork_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgNetwork_2eproto();
  friend void protobuf_ShutdownFile_MsgNetwork_2eproto();

  void InitAsDefaultInstance();
  static CMsgNetwork* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CMsgNetwork

// optional .CMsgInproc msgInproc = 2;
inline bool CMsgNetwork::has_msginproc() const {
  return RealMessage_case() == kMsgInproc;
}
inline void CMsgNetwork::set_has_msginproc() {
  _oneof_case_[0] = kMsgInproc;
}
inline void CMsgNetwork::clear_msginproc() {
  if (has_msginproc()) {
    delete RealMessage_.msginproc_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgInproc& CMsgNetwork::msginproc() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgInproc)
  return has_msginproc() ? *RealMessage_.msginproc_
                      : ::CMsgInproc::default_instance();
}
inline ::CMsgInproc* CMsgNetwork::mutable_msginproc() {
  if (!has_msginproc()) {
    clear_RealMessage();
    set_has_msginproc();
    RealMessage_.msginproc_ = new ::CMsgInproc;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgInproc)
  return RealMessage_.msginproc_;
}
inline ::CMsgInproc* CMsgNetwork::release_msginproc() {
  if (has_msginproc()) {
    clear_has_RealMessage();
    ::CMsgInproc* temp = RealMessage_.msginproc_;
    RealMessage_.msginproc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msginproc(::CMsgInproc* msginproc) {
  clear_RealMessage();
  if (msginproc) {
    set_has_msginproc();
    RealMessage_.msginproc_ = msginproc;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgInproc)
}

// optional .CMsgMove msgMove = 30002;
inline bool CMsgNetwork::has_msgmove() const {
  return RealMessage_case() == kMsgMove;
}
inline void CMsgNetwork::set_has_msgmove() {
  _oneof_case_[0] = kMsgMove;
}
inline void CMsgNetwork::clear_msgmove() {
  if (has_msgmove()) {
    delete RealMessage_.msgmove_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgMove& CMsgNetwork::msgmove() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgMove)
  return has_msgmove() ? *RealMessage_.msgmove_
                      : ::CMsgMove::default_instance();
}
inline ::CMsgMove* CMsgNetwork::mutable_msgmove() {
  if (!has_msgmove()) {
    clear_RealMessage();
    set_has_msgmove();
    RealMessage_.msgmove_ = new ::CMsgMove;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgMove)
  return RealMessage_.msgmove_;
}
inline ::CMsgMove* CMsgNetwork::release_msgmove() {
  if (has_msgmove()) {
    clear_has_RealMessage();
    ::CMsgMove* temp = RealMessage_.msgmove_;
    RealMessage_.msgmove_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msgmove(::CMsgMove* msgmove) {
  clear_RealMessage();
  if (msgmove) {
    set_has_msgmove();
    RealMessage_.msgmove_ = msgmove;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgMove)
}

// optional .CMsgConnect msgConnect = 30003;
inline bool CMsgNetwork::has_msgconnect() const {
  return RealMessage_case() == kMsgConnect;
}
inline void CMsgNetwork::set_has_msgconnect() {
  _oneof_case_[0] = kMsgConnect;
}
inline void CMsgNetwork::clear_msgconnect() {
  if (has_msgconnect()) {
    delete RealMessage_.msgconnect_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgConnect& CMsgNetwork::msgconnect() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgConnect)
  return has_msgconnect() ? *RealMessage_.msgconnect_
                      : ::CMsgConnect::default_instance();
}
inline ::CMsgConnect* CMsgNetwork::mutable_msgconnect() {
  if (!has_msgconnect()) {
    clear_RealMessage();
    set_has_msgconnect();
    RealMessage_.msgconnect_ = new ::CMsgConnect;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgConnect)
  return RealMessage_.msgconnect_;
}
inline ::CMsgConnect* CMsgNetwork::release_msgconnect() {
  if (has_msgconnect()) {
    clear_has_RealMessage();
    ::CMsgConnect* temp = RealMessage_.msgconnect_;
    RealMessage_.msgconnect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msgconnect(::CMsgConnect* msgconnect) {
  clear_RealMessage();
  if (msgconnect) {
    set_has_msgconnect();
    RealMessage_.msgconnect_ = msgconnect;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgConnect)
}

// optional .CMsgRoleSelect msgRoleSelect = 30004;
inline bool CMsgNetwork::has_msgroleselect() const {
  return RealMessage_case() == kMsgRoleSelect;
}
inline void CMsgNetwork::set_has_msgroleselect() {
  _oneof_case_[0] = kMsgRoleSelect;
}
inline void CMsgNetwork::clear_msgroleselect() {
  if (has_msgroleselect()) {
    delete RealMessage_.msgroleselect_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgRoleSelect& CMsgNetwork::msgroleselect() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgRoleSelect)
  return has_msgroleselect() ? *RealMessage_.msgroleselect_
                      : ::CMsgRoleSelect::default_instance();
}
inline ::CMsgRoleSelect* CMsgNetwork::mutable_msgroleselect() {
  if (!has_msgroleselect()) {
    clear_RealMessage();
    set_has_msgroleselect();
    RealMessage_.msgroleselect_ = new ::CMsgRoleSelect;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgRoleSelect)
  return RealMessage_.msgroleselect_;
}
inline ::CMsgRoleSelect* CMsgNetwork::release_msgroleselect() {
  if (has_msgroleselect()) {
    clear_has_RealMessage();
    ::CMsgRoleSelect* temp = RealMessage_.msgroleselect_;
    RealMessage_.msgroleselect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msgroleselect(::CMsgRoleSelect* msgroleselect) {
  clear_RealMessage();
  if (msgroleselect) {
    set_has_msgroleselect();
    RealMessage_.msgroleselect_ = msgroleselect;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgRoleSelect)
}

// optional .CMsgError msgError = 30005;
inline bool CMsgNetwork::has_msgerror() const {
  return RealMessage_case() == kMsgError;
}
inline void CMsgNetwork::set_has_msgerror() {
  _oneof_case_[0] = kMsgError;
}
inline void CMsgNetwork::clear_msgerror() {
  if (has_msgerror()) {
    delete RealMessage_.msgerror_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgError& CMsgNetwork::msgerror() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgError)
  return has_msgerror() ? *RealMessage_.msgerror_
                      : ::CMsgError::default_instance();
}
inline ::CMsgError* CMsgNetwork::mutable_msgerror() {
  if (!has_msgerror()) {
    clear_RealMessage();
    set_has_msgerror();
    RealMessage_.msgerror_ = new ::CMsgError;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgError)
  return RealMessage_.msgerror_;
}
inline ::CMsgError* CMsgNetwork::release_msgerror() {
  if (has_msgerror()) {
    clear_has_RealMessage();
    ::CMsgError* temp = RealMessage_.msgerror_;
    RealMessage_.msgerror_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msgerror(::CMsgError* msgerror) {
  clear_RealMessage();
  if (msgerror) {
    set_has_msgerror();
    RealMessage_.msgerror_ = msgerror;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgError)
}

// optional .CMsgRoleInfo msgRoleInfo = 30006;
inline bool CMsgNetwork::has_msgroleinfo() const {
  return RealMessage_case() == kMsgRoleInfo;
}
inline void CMsgNetwork::set_has_msgroleinfo() {
  _oneof_case_[0] = kMsgRoleInfo;
}
inline void CMsgNetwork::clear_msgroleinfo() {
  if (has_msgroleinfo()) {
    delete RealMessage_.msgroleinfo_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgRoleInfo& CMsgNetwork::msgroleinfo() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgRoleInfo)
  return has_msgroleinfo() ? *RealMessage_.msgroleinfo_
                      : ::CMsgRoleInfo::default_instance();
}
inline ::CMsgRoleInfo* CMsgNetwork::mutable_msgroleinfo() {
  if (!has_msgroleinfo()) {
    clear_RealMessage();
    set_has_msgroleinfo();
    RealMessage_.msgroleinfo_ = new ::CMsgRoleInfo;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgRoleInfo)
  return RealMessage_.msgroleinfo_;
}
inline ::CMsgRoleInfo* CMsgNetwork::release_msgroleinfo() {
  if (has_msgroleinfo()) {
    clear_has_RealMessage();
    ::CMsgRoleInfo* temp = RealMessage_.msgroleinfo_;
    RealMessage_.msgroleinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msgroleinfo(::CMsgRoleInfo* msgroleinfo) {
  clear_RealMessage();
  if (msgroleinfo) {
    set_has_msgroleinfo();
    RealMessage_.msgroleinfo_ = msgroleinfo;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgRoleInfo)
}

// optional .CMsgLoginStep msgLoginStep = 30007;
inline bool CMsgNetwork::has_msgloginstep() const {
  return RealMessage_case() == kMsgLoginStep;
}
inline void CMsgNetwork::set_has_msgloginstep() {
  _oneof_case_[0] = kMsgLoginStep;
}
inline void CMsgNetwork::clear_msgloginstep() {
  if (has_msgloginstep()) {
    delete RealMessage_.msgloginstep_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgLoginStep& CMsgNetwork::msgloginstep() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgLoginStep)
  return has_msgloginstep() ? *RealMessage_.msgloginstep_
                      : ::CMsgLoginStep::default_instance();
}
inline ::CMsgLoginStep* CMsgNetwork::mutable_msgloginstep() {
  if (!has_msgloginstep()) {
    clear_RealMessage();
    set_has_msgloginstep();
    RealMessage_.msgloginstep_ = new ::CMsgLoginStep;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgLoginStep)
  return RealMessage_.msgloginstep_;
}
inline ::CMsgLoginStep* CMsgNetwork::release_msgloginstep() {
  if (has_msgloginstep()) {
    clear_has_RealMessage();
    ::CMsgLoginStep* temp = RealMessage_.msgloginstep_;
    RealMessage_.msgloginstep_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msgloginstep(::CMsgLoginStep* msgloginstep) {
  clear_RealMessage();
  if (msgloginstep) {
    set_has_msgloginstep();
    RealMessage_.msgloginstep_ = msgloginstep;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgLoginStep)
}

// optional .CMsgCommon msgCommon = 30008;
inline bool CMsgNetwork::has_msgcommon() const {
  return RealMessage_case() == kMsgCommon;
}
inline void CMsgNetwork::set_has_msgcommon() {
  _oneof_case_[0] = kMsgCommon;
}
inline void CMsgNetwork::clear_msgcommon() {
  if (has_msgcommon()) {
    delete RealMessage_.msgcommon_;
    clear_has_RealMessage();
  }
}
inline const ::CMsgCommon& CMsgNetwork::msgcommon() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.msgCommon)
  return has_msgcommon() ? *RealMessage_.msgcommon_
                      : ::CMsgCommon::default_instance();
}
inline ::CMsgCommon* CMsgNetwork::mutable_msgcommon() {
  if (!has_msgcommon()) {
    clear_RealMessage();
    set_has_msgcommon();
    RealMessage_.msgcommon_ = new ::CMsgCommon;
  }
  // @@protoc_insertion_point(field_mutable:CMsgNetwork.msgCommon)
  return RealMessage_.msgcommon_;
}
inline ::CMsgCommon* CMsgNetwork::release_msgcommon() {
  if (has_msgcommon()) {
    clear_has_RealMessage();
    ::CMsgCommon* temp = RealMessage_.msgcommon_;
    RealMessage_.msgcommon_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CMsgNetwork::set_allocated_msgcommon(::CMsgCommon* msgcommon) {
  clear_RealMessage();
  if (msgcommon) {
    set_has_msgcommon();
    RealMessage_.msgcommon_ = msgcommon;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetwork.msgCommon)
}

// optional uint64 idSocket = 100000;
inline bool CMsgNetwork::has_idsocket() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMsgNetwork::set_has_idsocket() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMsgNetwork::clear_has_idsocket() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMsgNetwork::clear_idsocket() {
  idsocket_ = GOOGLE_ULONGLONG(0);
  clear_has_idsocket();
}
inline ::google::protobuf::uint64 CMsgNetwork::idsocket() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.idSocket)
  return idsocket_;
}
inline void CMsgNetwork::set_idsocket(::google::protobuf::uint64 value) {
  set_has_idsocket();
  idsocket_ = value;
  // @@protoc_insertion_point(field_set:CMsgNetwork.idSocket)
}

// optional bool bBroadcast = 100001;
inline bool CMsgNetwork::has_bbroadcast() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMsgNetwork::set_has_bbroadcast() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMsgNetwork::clear_has_bbroadcast() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMsgNetwork::clear_bbroadcast() {
  bbroadcast_ = false;
  clear_has_bbroadcast();
}
inline bool CMsgNetwork::bbroadcast() const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.bBroadcast)
  return bbroadcast_;
}
inline void CMsgNetwork::set_bbroadcast(bool value) {
  set_has_bbroadcast();
  bbroadcast_ = value;
  // @@protoc_insertion_point(field_set:CMsgNetwork.bBroadcast)
}

// repeated uint64 idPeer = 100002;
inline int CMsgNetwork::idpeer_size() const {
  return idpeer_.size();
}
inline void CMsgNetwork::clear_idpeer() {
  idpeer_.Clear();
}
inline ::google::protobuf::uint64 CMsgNetwork::idpeer(int index) const {
  // @@protoc_insertion_point(field_get:CMsgNetwork.idPeer)
  return idpeer_.Get(index);
}
inline void CMsgNetwork::set_idpeer(int index, ::google::protobuf::uint64 value) {
  idpeer_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgNetwork.idPeer)
}
inline void CMsgNetwork::add_idpeer(::google::protobuf::uint64 value) {
  idpeer_.Add(value);
  // @@protoc_insertion_point(field_add:CMsgNetwork.idPeer)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CMsgNetwork::idpeer() const {
  // @@protoc_insertion_point(field_list:CMsgNetwork.idPeer)
  return idpeer_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CMsgNetwork::mutable_idpeer() {
  // @@protoc_insertion_point(field_mutable_list:CMsgNetwork.idPeer)
  return &idpeer_;
}

inline bool CMsgNetwork::has_RealMessage() const {
  return RealMessage_case() != REALMESSAGE_NOT_SET;
}
inline void CMsgNetwork::clear_has_RealMessage() {
  _oneof_case_[0] = REALMESSAGE_NOT_SET;
}
inline CMsgNetwork::RealMessageCase CMsgNetwork::RealMessage_case() const {
  return CMsgNetwork::RealMessageCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MESSAGE_TYPE> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgNetwork_2eproto__INCLUDED
